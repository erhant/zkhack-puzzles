use super::{
    Digest, Felt, FieldElement, PrivKey, ProofOptions, Prover, PublicInputs, Rescue, SemaphoreAir,
    TraceTable, HASH_CYCLE_LEN, NUM_HASH_ROUNDS, TRACE_WIDTH,
};
use winterfell::{FieldExtension, HashFunction, Trace};

// SEMAPHORE PROVER
// ================================================================================================

pub struct SemaphoreProver {
    options: ProofOptions,
}

impl SemaphoreProver {
    /// Builds an execution trace for the computation required to generate a signal.
    pub fn build_trace(
        &self,
        priv_key: &PrivKey,
        key_index: usize,
        topic: Digest,
        merkle_path: &[Digest],
    ) -> TraceTable<Felt> {
        // allocate memory to hold the trace table
        let trace_length = merkle_path.len() * HASH_CYCLE_LEN;
        let mut trace = TraceTable::new(TRACE_WIDTH, trace_length);

        // skip the first node in the path since it will be generated by hashing priv_key
        let merkle_path = &merkle_path[1..];

        let priv_key = priv_key.elements();
        let topic: [Felt; 4] = topic.into();

        trace.fill(
            |state| {
                // initialize first state of the computation

                // -- merkle path section of the trace --
                state[0] = Felt::new(8);
                state[1] = Felt::ZERO;
                state[2] = Felt::ZERO;
                state[3] = Felt::ZERO;
                state[4] = priv_key[0];
                state[5] = priv_key[1];
                state[6] = priv_key[2];
                state[7] = priv_key[3];
                state[8] = Felt::ZERO;
                state[9] = Felt::ZERO;
                state[10] = Felt::ZERO;
                state[11] = Felt::ZERO;

                // -- nullifier section of the trace --
                state[12] = Felt::new(8);
                state[13] = Felt::ZERO;
                state[14] = Felt::ZERO;
                state[15] = Felt::ZERO;
                state[16] = priv_key[0];
                state[17] = priv_key[1];
                state[18] = priv_key[2];
                state[19] = priv_key[3];
                state[20] = topic[0];
                state[21] = topic[1];
                state[22] = topic[2];
                state[23] = topic[3];

                // -- index bits column --
                state[24] = Felt::ZERO;
            },
            |step, state| {
                // execute the transition function for all steps

                // determine which cycle we are in and also where in the cycle we are
                let cycle_num = step / HASH_CYCLE_LEN;
                let cycle_pos = step % HASH_CYCLE_LEN;

                if cycle_pos < NUM_HASH_ROUNDS {
                    // compute one round of Rescue hash in columns [0..12] for private key
                    // hashing and Merkle branch verification
                    apply_rescue_round(&mut state[..12], cycle_pos);
                    // compute one round of Rescue hash in columns [12..24] for nullifier
                    // computation
                    apply_rescue_round(&mut state[12..24], cycle_pos);
                } else {
                    let index_bit = Felt::new(((key_index >> cycle_num) & 1) as u64);
                    let path_node: [Felt; 4] = merkle_path[cycle_num].into();

                    if index_bit == Felt::ZERO {
                        // if index bit is zero, next path node goes into columns [8, 9, 10, 11];
                        // values in columns [4, 5, 6, 7] (the accumulated hash) remain unchanged
                        state[8] = path_node[0];
                        state[9] = path_node[1];
                        state[10] = path_node[2];
                        state[11] = path_node[3];
                    } else {
                        // if index bit is one, accumulated hash goes into columns [8, 9, 10, 11],
                        // and new path nodes goes into columns [4, 5, 6, 7]
                        state[8] = state[4];
                        state[9] = state[5];
                        state[10] = state[6];
                        state[11] = state[7];
                        state[4] = path_node[0];
                        state[5] = path_node[1];
                        state[6] = path_node[2];
                        state[7] = path_node[3];
                    }
                    // reset the capacity columns of the state by setting the first element to
                    // 8 (the number of elements to be hashed) and the rest to ZERO
                    state[0] = Felt::new(8);
                    state[1] = Felt::ZERO;
                    state[2] = Felt::ZERO;
                    state[3] = Felt::ZERO;

                    // make sure columns [16, 17, 18, 19] are the same as columns [4, 5, 6, 7],
                    // and everything else is set to ZERO
                    state[12] = Felt::ZERO;
                    state[13] = Felt::ZERO;
                    state[14] = Felt::ZERO;
                    state[15] = Felt::ZERO;
                    state[16] = state[4];
                    state[17] = state[5];
                    state[18] = state[6];
                    state[19] = state[7];
                    state[20] = Felt::ZERO;
                    state[21] = Felt::ZERO;
                    state[22] = Felt::ZERO;
                    state[23] = Felt::ZERO;

                    // save index bit in column 12
                    state[24] = index_bit;
                }
            },
        );

        // set index bit at the second step to one; this still results in a valid execution trace
        // because actual index bits are inserted into the trace after step 7, but it ensures
        // that there are no repeating patterns in the index bit column, and thus the degree
        // of the index bit constraint is stable.
        trace.set(24, 1, FieldElement::ONE);

        trace
    }
}

impl Prover for SemaphoreProver {
    type BaseField = Felt;
    type Air = SemaphoreAir;
    type Trace = TraceTable<Felt>;

    /// Returns [PublicInputs] built from the provided execution trace.
    fn get_pub_inputs(&self, trace: &Self::Trace) -> PublicInputs {
        // hash of the topic should be the first row, columns [20, 21, 22, 23]
        let topic = [
            trace.get(20, 0),
            trace.get(21, 0),
            trace.get(22, 0),
            trace.get(23, 0),
        ];

        // nullifier should be in the 7th row, columns [16, 17, 18, 19]
        let nullifier = [
            trace.get(16, 7),
            trace.get(17, 7),
            trace.get(18, 7),
            trace.get(19, 7),
        ];

        // root of the access set Merkle tree should be in the last row, columns [4, 5, 6, 7]
        let last_row_idx = trace.length() - 1;
        let tree_root = [
            trace.get(4, last_row_idx),
            trace.get(5, last_row_idx),
            trace.get(6, last_row_idx),
            trace.get(7, last_row_idx),
        ];

        PublicInputs {
            tree_root: tree_root.into(),
            nullifier: nullifier.into(),
            topic: topic.into(),
        }
    }

    fn options(&self) -> &ProofOptions {
        &self.options
    }
}

impl Default for SemaphoreProver {
    /// Returns a default prover configured for ~95 bit security level.
    fn default() -> Self {
        let options = ProofOptions::new(
            32,
            8,
            0,
            HashFunction::Blake3_256,
            FieldExtension::Quadratic,
            8,
            128,
        );
        Self { options }
    }
}

// HELPER FUNCTIONS
// ================================================================================================

fn apply_rescue_round(state: &mut [Felt], round: usize) {
    let mut state_array = [Felt::ZERO; 12];
    for (a_val, &s_val) in state_array.iter_mut().zip(state.iter()) {
        *a_val = s_val;
    }
    Rescue::apply_round(&mut state_array, round);
    for (s_val, &a_val) in state.iter_mut().zip(state_array.iter()) {
        *s_val = a_val;
    }
}
